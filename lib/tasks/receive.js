/**
 * This file is part of the TREZOR project.
 *
 * Copyright (C) 2015 SatoshiLabs <info@satoshilabs.com>
 *           (C) 2014 Mike Tsao <mike@sowbug.com>
 *           (C) 2015 William Wolf <throughnothing@gmail.com>
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */

'use strict';

/**
 * Logic of recieving data from trezor
 *
 * Logic of "call" is broken to two parts - sending and recieving
 */

var Promise = require('promise');
var hid = require('../chrome/hid');
var constants = require('../../constants.js');
var MessageDecoder = require('../protobuf/message_decoder.js');
var ByteBuffer = require('protobufjs').ByteBuffer;

/**
 * Parses first raw input that comes from Trezor and returns some information about the whole message.
 *
 * Throws error if something's wrong
 * @param {Uint8Array} bytes Bytes from Trezor
 * @returns {Object} d
 * @returns {integer} d.type Message type number
 * @returns {integer} d.length Expected length of the raw message, in bytes
 * @returns {ByteBuffer} d.buffer Buffer with the first part of message; can be non-complete
 */
function parseFirstInput(bytes) {

  // convert to ByteBuffer so it's easier to read
  var byteBuffer = ByteBuffer.concat([bytes]);

  // checking first two bytes
  var sharp1 = byteBuffer.readByte();
  var sharp2 = byteBuffer.readByte();
  if (sharp1 != constants.MESSAGE_HEADER_BYTE || sharp2 != constants.MESSAGE_HEADER_BYTE) {
    throw new Error("Didn't receive expected header signature.");
  }

  // reading things from header
  var type = byteBuffer.readUint16();
  var length = byteBuffer.readUint32();

  // creating a new buffer with the right size
  var resBuffer = new ByteBuffer(length);
  resBuffer.append(byteBuffer);

  return {
    type: type,
    length: length,
    buffer: resBuffer
  };

};


/**
 * If the whole message wasn't loaded in the first input, loads more inputs until everything is loaded.
 * @param {ByteBuffer} buffer Buffer with the already loaded message. This buffer *is modified* by this function.
 * @param {integer} id ConnectionId of Trezor (returned by chrome.hid.connect)
 * @param {integer} length Expected length of the raw message, in bytes
 * @param {Promise.<ByteBuffer>} Buffer with the message data
 */
function receiveRest(buffer, id, length) {

  if (buffer.offset >= length) {
    return Promise.resolve(buffer);
  }

  return hid.receive(id).then(function (data) {
    // sanity check
    if (data == null) {
      throw new Error("Received no data.");
    }

    buffer.append(data);
    return receiveRest(buffer, id, length);
  });
}

/**
 * Receives the whole message as a raw data buffer (but without headers or type info)
 * @param {integer} id ConnectionId of Trezor (returned by chrome.hid.connect)
 * @returns {Promise.<Object>} d
 * @returns {ArrayBuffer} d.buffer The message as a buffer
 * @returns {int} d.type Message type number
 */
function receiveBuffer(id) {
  return hid.receive(id).then(function (data) {
    var firstInput = parseFirstInput(data);

    return receiveRest(firstInput.buffer, id, firstInput.length).then(function (byteBuffer) {

      byteBuffer.reset();
      var buffer = byteBuffer.toArrayBuffer();
      return {
        buffer: buffer,
        type: firstInput.type
      };

    });

  });
}

/**
 * Reads data from device and returns decoded message, that can be sent back to trezor.js
 * @param {Object.<string, ProtoBuf.Builder.Message>} messages Builders, generated by reading config
 * @param {integer} id ConnectionId of Trezor (returned by chrome.hid.connect)
 * @returns {Promise.<Object>} res Promise with object that can get directly send to trezor.js
 * @returns {Object} res.message Message as JSON
 * @returns {string} res.type Message name
 */
function receive(messages, id) {

  return receiveBuffer(id).then(function (received) {
    var typeId = received.type;
    var buffer = received.buffer;
    var decoder = new MessageDecoder(messages, typeId, buffer);
    return {
      message: decoder.decodeJSON(),
      type: decoder.getMessageName()
    };
  });
}


module.exports = receive;
