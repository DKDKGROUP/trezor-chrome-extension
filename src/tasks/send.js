/* @flow */
/**
 * This file is part of the TREZOR project.
 *
 * Copyright (C) 2015 SatoshiLabs <info@satoshilabs.com>
 *           (C) 2014 Mike Tsao <mike@sowbug.com>
 *           (C) 2014 Liz Fong-Jones <lizf@google.com>
 *           (C) 2015 William Wolf <throughnothing@gmail.com>
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */

'use strict';

/**
 * Logic of sending data to trezor
 *
 * Logic of "call" is broken to two parts - sending and recieving
 */

import * as hid from "../chrome/hid";
import * as constants from "../constants.js";
import * as ProtoBuf from "protobufjs";
import {ByteBuffer} from "protobufjs";
import type {Messages} from "../protobuf/messages.js";



/**
 * Sends more buffers to device.
 * @param {integer} id ConnectionId of Trezor (returned by chrome.hid.connect)
 * @param {Array.<ArrayBuffer>} buffers Raw data to push to trezor.
 * @returns {Promise} Resolves iff everything gets sent
 */
function sendBuffers(id: number, buffers: Array<ArrayBuffer>): Promise<void> {

  return buffers.reduce(function (prevPromise: Promise<void>, buffer: ArrayBuffer) {
    return prevPromise.then(function () {
      return hid.send(id, buffer)
    })
  }, Promise.resolve(undefined));

}

// already built PB message
class BuiltMessage {
   message: ProtoBuf.Builder.Message;
   type: number;

   constructor(messages: Messages, // Builders, generated by reading config
                name: string, // Name of the message     
                data: Object // data as "pure" object, from trezor.js
              ) {
      var Builder = messages.messagesByName[name];
      if (Builder == null) {
        throw new Error("The message name " + name + " is not found.");
      }

      // cleans up stuff from angular and remove "null" that crashes in builder
      cleanupInput(data);

      if (data) {
        this.message = new Builder(data);
      } else {
        this.message = new Builder();
      } 
     
      this.type = messages.messageTypes['MessageType_' + name];
   }

   // encodes into "raw" data, but it can be too long and needs to be split into
   // smaller buffers
   _encodeLong(): Uint8Array {
     var headerSize: number = constants.HEADER_SIZE; // should be 8
     var bytes: Uint8Array = new Uint8Array(this.message.encodeAB());
     var fullSize: number = headerSize + bytes.length;

     var encodedByteBuffer = new ByteBuffer(fullSize);

     // first encode header

     // 2*1 byte
     encodedByteBuffer.writeByte(constants.MESSAGE_HEADER_BYTE);
     encodedByteBuffer.writeByte(constants.MESSAGE_HEADER_BYTE);

     // 2 bytes
     encodedByteBuffer.writeUint16(this.type);

     // 4 bytes (so 8 in total)
     encodedByteBuffer.writeUint32(bytes.length);

     // then put in the actual message

     encodedByteBuffer.append(bytes);

     // and convert to uint8 array
     // (it can still be too long to send though)
     var encoded: Uint8Array = new Uint8Array(encodedByteBuffer.buffer);

     return encoded;
  }
  
  // encodes itself and splits into "nice" chunks
  encode(): Array<ArrayBuffer> {
    var bytes: Uint8Array = this._encodeLong();

    var result: Array<ArrayBuffer> = [];
    var size: number = constants.BUFFER_SIZE;

    // How many pieces will there actually be
    var count: number = Math.round((bytes.length - 1) / size) + 1;

    // slice and dice 
    for (var i = 0; i < count; i++) {
        var slice: Uint8Array = bytes.subarray(i * size, (i + 1) * size);
        var newArray: Uint8Array = new Uint8Array(size);
        newArray.set(slice);
        result.push(newArray.buffer);
    }

    return result;
  }


}


// Removes $$hashkey from angular and remove nulls
function cleanupInput(message: Object): void {
  delete message.$$hashKey;

  for (var key in message) {

    var value = message[key];
    if (Array.isArray(value)) {
      value.forEach(function (i) {
        if (typeof i === "object") {
          cleanupInput(i);
        }
      });
    }
    if (typeof value === "object") {
      cleanupInput(value);
    }
    
    if (value === null) {
      delete message[value];
    }
  }
}


/**
 * Builds buffers to send.
 * @param {Object.<string, ProtoBuf.Builder.Message>} messages Builders, generated by reading config
 * @param {string} name Name of the message
 * @param {Object} data Data to serialize, exactly as given by trezor.js
 * @returns {Array.<Uint8Array>} Buffers that will be sent to Trezor
 */
function buildBuffers(messages: Messages, name: string, data: Object): Array<ArrayBuffer> {
  var message: BuiltMessage = new BuiltMessage(messages, name, data);
  var encoded: Array<ArrayBuffer> = message.encode();
  return encoded;
}

/**
 * Sends message to device.
 * @param {Object.<string, ProtoBuf.Builder.Message>} messages Builders, generated by reading config
 * @param {integer} id ConnectionId of Trezor (returned by chrome.hid.connect)
 * @param {string} name Name of the message
 * @param {Object} data Data to serialize, exactly as given by trezor.js
 * @returns {Promise} Resolves iff everything gets sent
 */
export function send(messages: Messages, id: number, name: string, data: Object): Promise<void> {
  var buffers: Array<ArrayBuffer> = buildBuffers(messages, name, data);
  return sendBuffers(id, buffers);
}

